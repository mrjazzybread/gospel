
# Table of Contents

1.  [Bird's eye view](#orgc5e87a2)
2.  [Code map](#orgb08249c)
    1.  [`Uparser`](#org12bc997)
    2.  [Untyped AST](#org740a04f)
    3.  [`Typing`](#orgda49b0e)
3.  [Tests](#org2557d08)
4.  [Strong Recommendations](#org7c0aa0a)


<a id="orgc5e87a2"></a>

# Bird's eye view

The Gospel type checker uses the OCaml parser to create an AST of the
OCaml file. We then traverse the generated AST, parse all Gospel
attributes and create an untyped Gospel AST, which is essentially a
fragment of the original OCaml AST combined with special Gospel nodes.

This AST is then fed into the type checker which leverages the `Inferno`
library to perform type inference. Before using the utilities exposed
by `Inferno`, however, we perform name resolution, type arity checks and
other tasks that that are not covered by `Inferno`. This process
generates another intermediate AST very similar to the previous Gospel
AST, the main difference being that each variable has been uniquely
tagged with an identifier.

Finally, each signature in this intermediate AST that contains a
Gospel term will be fed into the `Inferno` solver for type
inference. Assuming that there are no typing errors, a final typed AST
is produced. This AST is similar to the previous, except that every
term and every variable has a type associated with it.


<a id="orgb08249c"></a>

# Code map


<a id="org12bc997"></a>

## `Uparser`

Parses Gospel attributes written in the OCaml interface file. Note
that this parser does not concern itself with parsing OCaml
signatures, which is done by the OCaml parser provided by `ppx_lib`.


<a id="org740a04f"></a>

## Untyped AST

There are two untyped AST `parse_uast` and `id_uast`; the first is the
untyped parse tree generated by the `Uattr2spec` module which describes
an OCaml program annotated with Gospel attributes. Naturally, this AST
contains nodes similar to those found in `Parsetree` module from
`Ppx_lib`. This AST also defines the structure of Gospel terms, which is
effectively a fragment of OCaml expressions augmented with quantifiers
and other logical expressions.

The second AST `IdUast` is extremely similar to the previous with a few
minor differences, the most important being:

-   Identifiers are fully resolved and uniquely tagged.
-   Each type name has additional information such as its type alias.

Note that both ASTs are very similar to one another; if a new
construct is added to the language, it will almost always imply adding
the exact same node to both ASTs.

The reason why we have two very similar ASTs is because `Inferno` cannot
perform name resolution in the presence of named scopes (in our case,
modules). Thus, the AST that we feed the `Inferno` solver is one where
name resolution has already been done.


<a id="orgda49b0e"></a>

## `Typing`

The `Typing` module, as the name implies, takes an untyped Gospel AST
and turns it into a typed AST. Since typechecking is quite
complicated, the logic for typechecking is divided among two other
modules: `Solver`, which performs type inference using Inferno, and
`Namespace` which keep track of what variables are in scope and the
information associated with them (the information depends on whether
it is an identifier for a type, a variable, etc&#x2026; but it should
always includes a uniquely tagged variable). The `Typing` module
leverages the utilities exposed by both of these modules


<a id="org2557d08"></a>

# Tests

The tests are almost all expect tests; each test is an OCaml interface
file where the expected error message is at the bottom in an OCaml
comment (if no error is expected, no comment is found). If a change to
the type checker changes an error message, then either there is a bug
(most likely) or the expected error message has changed; in the latter
case run `dune promote` after `dune test` to update the error message.

To add a new expect test, navigate to the directory you want to add
the test to and create the `.mli` file with your test. You may then run
`dune test && dune promote` to generate the dune rules for your new test
and then `dune test` again to see if the test produces the output you
expect. If so, you may run `dune promote` again to generate the OCaml
comment with the expected output. Running `dune test` again should
succeed with no errors.

If you wish to create your tests in a new directory, the steps are the
same as in the previous paragraph, but you must create a `dune` file
where you include the following stanzas `(include path) (include
dune.inc)` where `path` is replaced with the relative path to the file
`dune.common`. Additionally, you must create an empty `dune.inc` file.

If you wish to add tests whose behaviour cannot be defined with an
expect test, we recommend creating a directory test (more info in
<https://dune.readthedocs.io/en/stable/tests.html>)


<a id="org7c0aa0a"></a>

# Strong Recommendations

If you wish to contribute to Gospel, you should ensure that in each
commit your code is correctly formatted (to do this, run `dune fmt`) and
that each test still passes. One way of ensuring this is creating a
[pre-commit](https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks) hook with the command `dune fmt --preview && dune test`. This
way, invalid commits are caught before they are pushed (note that
hooks can always be disabled if needed).

