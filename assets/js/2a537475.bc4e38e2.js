"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[681],{5680:(e,n,t)=>{t.d(n,{xA:()=>u,yg:()=>h});var a=t(6540);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var s=a.createContext({}),p=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},u=function(e){var n=p(e.components);return a.createElement(s.Provider,{value:n},e.children)},d="mdxType",c={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),d=p(t),m=i,h=d["".concat(s,".").concat(m)]||d[m]||c[m]||o;return t?a.createElement(h,r(r({ref:n},u),{},{components:t})):a.createElement(h,r({ref:n},u))}));function h(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var o=t.length,r=new Array(o);r[0]=m;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l[d]="string"==typeof e?e:i,r[1]=l;for(var p=2;p<o;p++)r[p]=t[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},8996:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>r,default:()=>c,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var a=t(8168),i=(t(6540),t(5680));const o={sidebar_position:3},r="Mutable Queues",l={unversionedId:"walkthroughs/mutable-queue",id:"walkthroughs/mutable-queue",title:"Mutable Queues",description:"This example aims to provide a formal specification for a mutable queue data",source:"@site/docs/walkthroughs/mutable-queue.md",sourceDirName:"walkthroughs",slug:"/walkthroughs/mutable-queue",permalink:"/gospel/walkthroughs/mutable-queue",draft:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Fibonacci Numbers",permalink:"/gospel/walkthroughs/fibonacci"},next:{title:"Union-find",permalink:"/gospel/walkthroughs/union-find"}},s={},p=[{value:"Modeling the Queue Datastructure",id:"modeling-the-queue-datastructure",level:2},{value:"Pushing Into the Queue",id:"pushing-into-the-queue",level:2},{value:"Various Flavors of <code>pop</code>",id:"various-flavors-of-pop",level:2},{value:"Exceptional Version",id:"exceptional-version",level:3},{value:"Unsafe Version",id:"unsafe-version",level:3},{value:"Defensive Version",id:"defensive-version",level:3},{value:"A Small Break: <code>is_empty</code>",id:"a-small-break-is_empty",level:2},{value:"Creating Queues",id:"creating-queues",level:2},{value:"Merging Queues",id:"merging-queues",level:2},{value:"In-Place Transfer",id:"in-place-transfer",level:3},{value:"Destructive Operations",id:"destructive-operations",level:3},{value:"A Constructive Version",id:"a-constructive-version",level:3}],u={toc:p},d="wrapper";function c(e){let{components:n,...t}=e;return(0,i.yg)(d,(0,a.A)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,i.yg)("h1",{id:"mutable-queues"},"Mutable Queues"),(0,i.yg)("p",null,"This example aims to provide a formal specification for a mutable queue data\nstructure, similar to OCaml's standard library ",(0,i.yg)("inlineCode",{parentName:"p"},"Queue"),"."),(0,i.yg)("p",null,"This work is adapted from the article ",(0,i.yg)("em",{parentName:"p"},"GOSPEL -Providing OCaml with a Formal\nSpecification Language"),(0,i.yg)("sup",{parentName:"p",id:"fnref-1"},(0,i.yg)("a",{parentName:"sup",href:"#fn-1",className:"footnote-ref"},"1")),", which also\nfeatures an implementation of the following specification that was formally\nverified using Why3gospel."),(0,i.yg)("h2",{id:"modeling-the-queue-datastructure"},"Modeling the Queue Datastructure"),(0,i.yg)("p",null,"Let's start by defining the type of queues. The ",(0,i.yg)("inlineCode",{parentName:"p"},"'a t")," type represents a\npolymorphic queue, storing elements of type ",(0,i.yg)("inlineCode",{parentName:"p"},"'a"),". To enable reasoning about the\nelements of a queue, we attach one model to its type declaration:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ocaml"},"type 'a t\n(*@ mutable model view: 'a sequence *)\n")),(0,i.yg)("p",null,"The model ",(0,i.yg)("inlineCode",{parentName:"p"},"view")," represents the mathematical sequence of elements stored in\nthe queue. The type ",(0,i.yg)("inlineCode",{parentName:"p"},"'a sequence")," is the type of logical sequences defined in the\nGospel standard library and is for specifications only. The ",(0,i.yg)("inlineCode",{parentName:"p"},"mutable"),"\nkeyword states that the ",(0,i.yg)("inlineCode",{parentName:"p"},"view")," field can change over time."),(0,i.yg)("admonition",{type:"tip"},(0,i.yg)("p",{parentName:"admonition"},"This shows how Gospel annotations provide extra insight and are also relevant\nfor documentation. The ",(0,i.yg)("inlineCode",{parentName:"p"},"mutable")," keyword states that the type ",(0,i.yg)("inlineCode",{parentName:"p"},"'a t")," is mutable,\nwhich cannot be deduced from its OCaml declaration alone.")),(0,i.yg)("h2",{id:"pushing-into-the-queue"},"Pushing Into the Queue"),(0,i.yg)("p",null,"Now let's declare and specify a ",(0,i.yg)("inlineCode",{parentName:"p"},"push")," operation for these queues:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ocaml"},"val push: 'a -> 'a t -> unit\n(*@ push v q\n    modifies q\n    ensures  q.view = Sequence.cons v (old q.view) *)\n")),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"The first line of the specification is the header; it names the two arguments\nof ",(0,i.yg)("inlineCode",{parentName:"li"},"push"),": ",(0,i.yg)("inlineCode",{parentName:"li"},"v")," and ",(0,i.yg)("inlineCode",{parentName:"li"},"q"),"."),(0,i.yg)("li",{parentName:"ul"},"The ",(0,i.yg)("inlineCode",{parentName:"li"},"modifies")," clause states that the function ",(0,i.yg)("inlineCode",{parentName:"li"},"push")," may mutate the contents\nof ",(0,i.yg)("inlineCode",{parentName:"li"},"q"),"."),(0,i.yg)("li",{parentName:"ul"},"Finally, the ",(0,i.yg)("inlineCode",{parentName:"li"},"ensures")," clause introduces a postcondition that describes the\nmodel ",(0,i.yg)("inlineCode",{parentName:"li"},"view")," of ",(0,i.yg)("inlineCode",{parentName:"li"},"q")," after a call to ",(0,i.yg)("inlineCode",{parentName:"li"},"push"),". The new ",(0,i.yg)("inlineCode",{parentName:"li"},"view")," extends the old\nvalue of ",(0,i.yg)("inlineCode",{parentName:"li"},"view")," with the element ",(0,i.yg)("inlineCode",{parentName:"li"},"v")," at the front. We use the keyword ",(0,i.yg)("inlineCode",{parentName:"li"},"old")," to\nrefer to the value of an expression (here, ",(0,i.yg)("inlineCode",{parentName:"li"},"q.view"),") in the prestate, ",(0,i.yg)("em",{parentName:"li"},"i.e."),",\nbefore the function call.")),(0,i.yg)("p",null,"Note that the module ",(0,i.yg)("inlineCode",{parentName:"p"},"Sequence")," is part of the Gospel standard library and\nshould not be confused with module ",(0,i.yg)("inlineCode",{parentName:"p"},"Seq")," from the OCaml standard library."),(0,i.yg)("h2",{id:"various-flavors-of-pop"},"Various Flavors of ",(0,i.yg)("inlineCode",{parentName:"h2"},"pop")),(0,i.yg)("p",null,"Now let's move to another function, ",(0,i.yg)("inlineCode",{parentName:"p"},"pop"),", and illustrate three ways of\nhandling assumptions from the client in Gospel specifications."),(0,i.yg)("h3",{id:"exceptional-version"},"Exceptional Version"),(0,i.yg)("p",null,"In this version, similar to the one provided by the OCaml standard library,\n",(0,i.yg)("inlineCode",{parentName:"p"},"pop")," raises an ",(0,i.yg)("inlineCode",{parentName:"p"},"Empty")," exception if its argument is an empty queue. We specify\nthis behaviour as follows:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ocaml"},"exception Empty\n\nval pop: 'a t -> 'a\n(*@ v = pop q\n    modifies q\n    ensures  old q.view = q.view ++ Sequence.cons v Sequence.empty\n    raises   Empty -> q.view = old q.view = Sequence.empty *)\n")),(0,i.yg)("p",null,"We have two postconditions:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"The first one, introduced with ",(0,i.yg)("inlineCode",{parentName:"li"},"ensures"),", states the postcondition that holds\nwhenever the function ",(0,i.yg)("inlineCode",{parentName:"li"},"pop")," returns a value ",(0,i.yg)("inlineCode",{parentName:"li"},"v"),"."),(0,i.yg)("li",{parentName:"ul"},"The second one, introduced by ",(0,i.yg)("inlineCode",{parentName:"li"},"raises"),", states the exceptional postcondition\nthat holds whenever the call raises the exception ",(0,i.yg)("inlineCode",{parentName:"li"},"Empty"),".")),(0,i.yg)("p",null,"Similarly to the ",(0,i.yg)("inlineCode",{parentName:"p"},"push")," case, the clause ",(0,i.yg)("inlineCode",{parentName:"p"},"modifies")," indicates that this function\ncall may mutate ",(0,i.yg)("inlineCode",{parentName:"p"},"q"),". Note that this applies to the exceptional case as well, and\nthat's why we state that ",(0,i.yg)("inlineCode",{parentName:"p"},"q")," is both empty and not modified."),(0,i.yg)("h3",{id:"unsafe-version"},"Unsafe Version"),(0,i.yg)("p",null,"Now, let us consider an unsafe variant of ",(0,i.yg)("inlineCode",{parentName:"p"},"pop")," that should only be called on a\nnon-empty queue, leaving the responsibility of that property to the client code.\nThe function does not raise ",(0,i.yg)("inlineCode",{parentName:"p"},"Empty")," anymore but instead expects a non-empty\nargument. We can thus add the following precondition to the contract using the\nkeyword ",(0,i.yg)("inlineCode",{parentName:"p"},"requires"),":"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ocaml",metastring:"{3}","{3}":!0},"val unsafe_pop: 'a t -> 'a\n(*@ v = unsafe_pop q\n    requires q.view <> Sequence.empty\n    modifies q\n    ensures  old q.view = q.view ++ (Sequence.cons v Sequence.empty) *)\n")),(0,i.yg)("h3",{id:"defensive-version"},"Defensive Version"),(0,i.yg)("p",null,"Instead of assuming that the precondition is guaranteed by the caller, we can\nalso adopt a more defensive approach where ",(0,i.yg)("inlineCode",{parentName:"p"},"pop")," raises ",(0,i.yg)("inlineCode",{parentName:"p"},"Invalid_argument"),"\nwhenever an empty queue is provided. Gospel provides a way to declare such a\nbehavior, using ",(0,i.yg)("inlineCode",{parentName:"p"},"checks")," instead of ",(0,i.yg)("inlineCode",{parentName:"p"},"requires"),":"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ocaml",metastring:"{3}","{3}":!0},"val pop: 'a t -> 'a\n(*@ v = pop q\n      checks   q.view <> Sequence.empty\n      modifies q\n      ensures  old q.view = q.view ++ (Sequence.cons v Sequence.empty) *)\n")),(0,i.yg)("p",null,"The ",(0,i.yg)("inlineCode",{parentName:"p"},"checks")," keyword means that function itself checks the pre-condition\n",(0,i.yg)("inlineCode",{parentName:"p"},"q.view <> empty")," and raises ",(0,i.yg)("inlineCode",{parentName:"p"},"Invalid_argument")," whenever it does not hold. Note\nthat ",(0,i.yg)("inlineCode",{parentName:"p"},"q.view")," is just a logical model and may not exist at all in the\nimplementation. However, the function checks a property that, from a logical\npoint of view, results in ",(0,i.yg)("inlineCode",{parentName:"p"},"q.view")," not being empty."),(0,i.yg)("h2",{id:"a-small-break-is_empty"},"A Small Break: ",(0,i.yg)("inlineCode",{parentName:"h2"},"is_empty")),(0,i.yg)("p",null,"Our next function needs a simpler specification. Consider the following\ndeclaration for an emptiness test, together with its contract:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ocaml"},"val is_empty: 'a t -> bool\n(*@ b = is_empty q\n      ensures b <-> q.view = Sequence.empty *)\n")),(0,i.yg)("p",null,"The postconditions capture that the function returns ",(0,i.yg)("inlineCode",{parentName:"p"},"true")," if and only if the\nqueue is empty."),(0,i.yg)("p",null,"Although very simple, the above specification implies an important\nproperty. Since no ",(0,i.yg)("inlineCode",{parentName:"p"},"modifies")," clause is present, the argument ",(0,i.yg)("inlineCode",{parentName:"p"},"q")," is read-only.\nWe know that a call to ",(0,i.yg)("inlineCode",{parentName:"p"},"is_empty")," does not modify ",(0,i.yg)("inlineCode",{parentName:"p"},"q.view"),"."),(0,i.yg)("h2",{id:"creating-queues"},"Creating Queues"),(0,i.yg)("p",null,"The next function features the creation of a queue. Its declaration and\nspecification are as follows:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ocaml"},"val create: unit -> 'a t\n(*@ q = create ()\n      ensures q.view = Sequence.empty *)\n")),(0,i.yg)("p",null,"The newly created queue has no elements. Its ",(0,i.yg)("inlineCode",{parentName:"p"},"view")," model equals the ",(0,i.yg)("inlineCode",{parentName:"p"},"empty"),"\nsequence, as stated by the postcondition."),(0,i.yg)("p",null,"It's worth mentioning that the specification implicitly assumes ",(0,i.yg)("inlineCode",{parentName:"p"},"q")," to be\ndisjoint from every previously allocated queue. This is an important design\nchoice of Gospel that follows this general principle: writing functions that\nreturn non-fresh, mutable values is considered a bad practice in OCaml."),(0,i.yg)("h2",{id:"merging-queues"},"Merging Queues"),(0,i.yg)("p",null,"Let's conclude this specification with a function to merge two queues. Several\napproaches are possible, so we'll showcase three of them."),(0,i.yg)("h3",{id:"in-place-transfer"},"In-Place Transfer"),(0,i.yg)("p",null,"Start with a concatenation that transfers all elements from one queue to\nanother:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ocaml"},"val transfer: 'a t -> 'a t -> unit\n(*@ transfer src dst\n    modifies src, dst\n    ensures  src.view = Sequence.empty\n    ensures  dst.view = old dst.view ++ old src.view *)\n")),(0,i.yg)("p",null,"Here the contract states that both queues are modified. The queue ",(0,i.yg)("inlineCode",{parentName:"p"},"src")," is\nemptied after the call and its elements are appended to the queue ",(0,i.yg)("inlineCode",{parentName:"p"},"dst"),". Notice\nthe use of ",(0,i.yg)("inlineCode",{parentName:"p"},"old")," in the second postcondition. This helps us refer to the queues'\nstate before they're passed to the function."),(0,i.yg)("h3",{id:"destructive-operations"},"Destructive Operations"),(0,i.yg)("p",null,"One could think of a slightly different version of ",(0,i.yg)("inlineCode",{parentName:"p"},"transfer"),":\n",(0,i.yg)("inlineCode",{parentName:"p"},"destructive_transfer"),", which invalidates ",(0,i.yg)("inlineCode",{parentName:"p"},"src")," when called. In other words, the\nvalue of ",(0,i.yg)("inlineCode",{parentName:"p"},"src")," should be considered ",(0,i.yg)("em",{parentName:"p"},"dirty"),", so it must not be used in the\nrest of the program. Such use cases are frequent in system programming, like\nwhen dealing with file descriptors after closing them. Gospel\nprovides ",(0,i.yg)("inlineCode",{parentName:"p"},"consumes")," clauses to capture this semantic:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ocaml",metastring:"{3}","{3}":!0},"val destructive_transfer: 'a t -> 'a t -> unit\n(*@ destructive_transfer src dst\n    consumes src\n    modifies dst\n    ensures  dst.view = old dst.view ++ old src.view *)\n")),(0,i.yg)("p",null,"Note that we don't need to give information on ",(0,i.yg)("inlineCode",{parentName:"p"},"src")," in the poststate, since\nits value must not be used anymore."),(0,i.yg)("h3",{id:"a-constructive-version"},"A Constructive Version"),(0,i.yg)("p",null,"Finally, perhaps a simpler version may consist in a ",(0,i.yg)("inlineCode",{parentName:"p"},"concat")," function that\ncreates a fresh queue with the elements of the queues passed as arguments:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ocaml"},"val concat: 'a t -> 'a t -> 'a t\n(*@ new = concat q1 q2\n    ensures new.view = q1.view ++ q2.view *)\n")),(0,i.yg)("p",null,"In this version, no ",(0,i.yg)("inlineCode",{parentName:"p"},"modifies")," appears. This means that none of the arguments\nare modified by the function, so specifying their models in the poststate isn't\nnecessary."),(0,i.yg)("div",{className:"footnotes"},(0,i.yg)("hr",{parentName:"div"}),(0,i.yg)("ol",{parentName:"div"},(0,i.yg)("li",{parentName:"ol",id:"fn-1"},"Arthur Chargu\xe9raud, Jean-Christophe Filli\xe2tre, Cl\xe1udio Louren\xe7o, M\xe1rio\nPereira. GOSPEL -Providing OCaml with a Formal Specification Language. FM\n2019 - 23rd International Symposium on Formal Methods, Oct 2019, Porto,\nPortugal. \u27e8",(0,i.yg)("a",{parentName:"li",href:"https://hal.inria.fr/hal-02157484"},"hal-02157484"),"\u27e9",(0,i.yg)("a",{parentName:"li",href:"#fnref-1",className:"footnote-backref"},"\u21a9")))))}c.isMDXComponent=!0}}]);