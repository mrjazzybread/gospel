"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[214],{5680:(e,n,t)=>{t.d(n,{xA:()=>m,yg:()=>c});var a=t(6540);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var l=a.createContext({}),u=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},m=function(e){var n=u(e.components);return a.createElement(l.Provider,{value:n},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},h=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),p=u(t),h=i,c=p["".concat(l,".").concat(h)]||p[h]||d[h]||o;return t?a.createElement(c,r(r({ref:n},m),{},{components:t})):a.createElement(c,r({ref:n},m))}));function c(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var o=t.length,r=new Array(o);r[0]=h;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[p]="string"==typeof e?e:i,r[1]=s;for(var u=2;u<o;u++)r[u]=t[u];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}h.displayName="MDXCreateElement"},3455:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>u});var a=t(8168),i=(t(6540),t(5680));const o={sidebar_position:4},r="Union-find",s={unversionedId:"walkthroughs/union-find",id:"walkthroughs/union-find",title:"Union-find",description:"In this example, we will highlight an advanced use case of ghost declarations in",source:"@site/docs/walkthroughs/union-find.md",sourceDirName:"walkthroughs",slug:"/walkthroughs/union-find",permalink:"/gospel/walkthroughs/union-find",draft:!1,tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"Mutable Queues",permalink:"/gospel/walkthroughs/mutable-queue"},next:{title:"Gospel Special Comment Syntax",permalink:"/gospel/language/syntax"}},l={},u=[{value:"Why is this hard to specify?",id:"why-is-this-hard-to-specify",level:2},{value:"Introducing the Ghost Universe",id:"introducing-the-ghost-universe",level:2},{value:"Elements: Gotta Catch &#39;em All",id:"elements-gotta-catch-em-all",level:2},{value:"Find Your Representative",id:"find-your-representative",level:2}],m={toc:u},p="wrapper";function d(e){let{components:n,...t}=e;return(0,i.yg)(p,(0,a.A)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,i.yg)("h1",{id:"union-find"},"Union-find"),(0,i.yg)("p",null,"In this example, we will highlight an advanced use case of ghost declarations in\nGospel through the specification of a union-find datastructure."),(0,i.yg)("p",null,(0,i.yg)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Disjoint-set_data_structure"},"Union-find")," is a\nfairly simple datastructure used to keep track of a collection of elements\npartitioned into disjoint sets. Its most simple interface is as follows:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ocaml"},"type 'a element\n(** The type for set elements. *)\n\nval make : 'a -> 'a element\n(** [make x] is the singleton containing an element wrapping [x]. *)\n\nval find : 'a element -> 'a element\n(** [find e] is the representative of the subset containing [e]. *)\n\nval union : 'a element -> 'a element -> unit\n(** [union x y] merges the subset containing [x] with the subset\n    containing [y]. *)\n")),(0,i.yg)("h2",{id:"why-is-this-hard-to-specify"},"Why is this hard to specify?"),(0,i.yg)("p",null,"Union-find structures store a partition of a set. Notice that a typical\ninterface for union-find doesn't materialise this greater set (let's call it\nour ",(0,i.yg)("em",{parentName:"p"},"universe"),"). Instead, the programmer has access to individual elements of\nthe set, so they may merge them or access a representative of its partition."),(0,i.yg)("p",null,"However, for the sake of specification, not having this global set is a problem.\nHow can we state that the subsets are disjoint? How do we refer to the set of\nelements that exist in the union-find universe? Can we even tell that the\nrepresentative of an element (returned by ",(0,i.yg)("inlineCode",{parentName:"p"},"find"),") is indeed part of a subset\nthat was ",(0,i.yg)("inlineCode",{parentName:"p"},"union"),"ed with it at some point? It seems that we cannot do any of\nthese by attaching contracts to our functions and type only."),(0,i.yg)("p",null,"This example shows how Gospel's ",(0,i.yg)("em",{parentName:"p"},"ghost declarations")," help describe such complex\nbehaviours."),(0,i.yg)("h2",{id:"introducing-the-ghost-universe"},"Introducing the Ghost Universe"),(0,i.yg)("p",null,"Seemingly, the root of our problems is that union-find relies on the implicit\nuniverse of elements. It doesn't exist in the OCaml's interface, so let's\nintroduce it as a ghost-type declaration. We can also add that this universe is\nmutable. As long as elements are added, for instance, it will be modified."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ocaml"},"(*@ type 'a universe *)\n(*@ ephemeral *)\n")),(0,i.yg)("p",null,"Now, our three functions still apply to set elements, but they also apply ",(0,i.yg)("em",{parentName:"p"},"in\nthe context of a universe")," since you create a new singleton subset in the\ncontext of the greater set, or find the representative of an element in the rest\nof the universe. This translates into our three functions taking a value of type\n",(0,i.yg)("inlineCode",{parentName:"p"},"'a universe")," as its argument. Of course, ",(0,i.yg)("inlineCode",{parentName:"p"},"'a universe")," is a ghost type and you\ndon't want to modify the functions' signatures anyway, so this argument is\nghost, too",(0,i.yg)("sup",{parentName:"p",id:"fnref-1"},(0,i.yg)("a",{parentName:"sup",href:"#fn-1",className:"footnote-ref"},"1")),". We already get a sense that ",(0,i.yg)("inlineCode",{parentName:"p"},"make")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"union")," will modify the\nuniverse."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ocaml"},"val make : 'a -> 'a element\n(*@ e = make [u: 'a universe] v\n    modifies u *)\n\nval find : 'a element -> 'a element\n(*@ e = find [u: 'a universe] x *)\n\nval union : 'a element -> 'a element -> unit\n(*@ union [u: 'a universe] x y\n    modifies u *)\n")),(0,i.yg)("p",null,"Since we now have a type for universes, and functions that take values of such\na type, we probably need a constructor for this type. Let's introduce that as a\nghost value:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ocaml"},"(*@ val make_universe: unit -> 'a universe *)\n")),(0,i.yg)("p",null,"Having this abstract type on is not very useful so far. We're able to state\nthat the functions apply in the context of a universe and they may mutate\nit, but that's pretty much it. Let's be more precise than that."),(0,i.yg)("h2",{id:"elements-gotta-catch-em-all"},"Elements: Gotta Catch 'em All"),(0,i.yg)("p",null,"The first interesting property to capture is that the subsets\nare indeed disjoint. For instance, ",(0,i.yg)("inlineCode",{parentName:"p"},"make")," shouldn't create an element that's\nalready in the universe, otherwise you'd have two different subsets\ncontaining the same element."),(0,i.yg)("p",null,"In order to specify this, we need to talk about the set of existing\nelements in the universe. Let's introduce this as a logical model attached to\nour ",(0,i.yg)("inlineCode",{parentName:"p"},"universe")," type:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ocaml"},"(*@ type 'a universe *)\n(*@ mutable model dom : 'a element set *)\n")),(0,i.yg)("admonition",{type:"tip"},(0,i.yg)("p",{parentName:"admonition"},"Since at least one model is mutable, we may now omit the ",(0,i.yg)("inlineCode",{parentName:"p"},"ephemeral")," keyword\n(although it's also valid to keep it if you prefer). For instance, you may keep\nit if you want to indicate that the type is also mutable in a way that is not\nvisible in the models.")),(0,i.yg)("p",null,"Now let's add more information on how the functions interact with it. The\nconstructor should ensure two things:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"The returned element is a fresh element."),(0,i.yg)("li",{parentName:"ul"},"The universe's domain is augmented with the singleton containing the\nprovided value.")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ocaml",metastring:"{4,5}","{4,5}":!0},"val make : 'a -> 'a element\n(*@ e = make [u: 'a universe] v\n    modifies u.dom\n    ensures not (Set.mem e (old u.dom))\n    ensures u.dom = Set.add e (old u.dom) *)\n")),(0,i.yg)("p",null,"The ",(0,i.yg)("inlineCode",{parentName:"p"},"find")," function obviously needs an element of the universe, and it also\nreturns an element that's part of the universe:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ocaml",metastring:"{3,4}","{3,4}":!0},"val find : 'a element -> 'a element\n(*@ e = find [u: 'a universe] x\n    requires Set.mem x u.dom\n    ensures Set.mem e u.dom *)\n")),(0,i.yg)("p",null,"Finally, ",(0,i.yg)("inlineCode",{parentName:"p"},"union")," requires that the provided elements are part of the universe\ntoo. Please note: it doesn't modify the universe domain (no element is added nor\nremoved); however, since we added the ",(0,i.yg)("inlineCode",{parentName:"p"},"modify u")," clause, we need to state that\nexplicitly, or the contract may imply that ",(0,i.yg)("inlineCode",{parentName:"p"},"u.dom")," was modified (in an\nunspecified way)."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ocaml",metastring:"{3-4,6}","{3-4,6}":!0},"val union : 'a element -> 'a element -> unit\n(*@ union [u: 'a universe] x y\n    requires Set.mem x u.dom\n    requires Set.mem y u.dom\n    modifies u\n    ensures u.dom = old u.dom *)\n")),(0,i.yg)("h2",{id:"find-your-representative"},"Find Your Representative"),(0,i.yg)("p",null,"We can now talk about all the elements in our partition, but we still haven't\nmentioned the elements' representatives. Each element in the universe has a\nrepresentative in the set, so we can represent this using a ",(0,i.yg)("inlineCode",{parentName:"p"},"'a element -> 'a\nelement")," function. We can also add two invariants:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"The representative of an element must live in the same universe as the\nelement itself."),(0,i.yg)("li",{parentName:"ul"},"The ",(0,i.yg)("inlineCode",{parentName:"li"},"rep")," function is idempotent: the representative of an element is its own\nrepresentative.")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ocaml",metastring:"{3-5}","{3-5}":!0},"(*@ type 'a universe *)\n(*@ mutable model dom : 'a element set\n    mutable model rep : 'a element -> 'a element\n    with u\n    invariant forall e. Set.mem e u.dom -> Set.mem (u.rep e) u.dom\n    invariant forall e. Set.mem e u.dom -> u.rep (u.rep e) = u.rep e *)\n")),(0,i.yg)("admonition",{type:"caution"},(0,i.yg)("p",{parentName:"admonition"},"Notice how in both cases, speaking of the element's representative only makes\nsense for elements that live in the universe. However, Gospel's logic is total,\nso ",(0,i.yg)("inlineCode",{parentName:"p"},"rep")," is also defined outside of the universe; however, it's unspecified\nthere.")),(0,i.yg)("p",null,"Now let's add clauses to our functions that indicate how they interact with\n",(0,i.yg)("inlineCode",{parentName:"p"},"rep"),". After a call to our constructor, the created element is obviously its own\nrepresentative, and all other representatives are left unchanged:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ocaml",metastring:"{6}","{6}":!0},"val make : 'a -> 'a element\n(*@ e = make [u: 'a universe] v\n    modifies u.dom\n    ensures not (Set.mem e (old u.dom))\n    ensures u.dom = Set.add e (old u.dom)\n    ensures u.rep = (old u.rep)[e -> e] *)\n")),(0,i.yg)("admonition",{type:"note"},(0,i.yg)("p",{parentName:"admonition"},"The ",(0,i.yg)("inlineCode",{parentName:"p"},"_[_ -> _]")," operator is defined in the ",(0,i.yg)("a",{parentName:"p",href:"../stdlib"},"standard library"),". The\nnotation ",(0,i.yg)("inlineCode",{parentName:"p"},"f[x -> y]")," is a shorthand notation for the function defined as ",(0,i.yg)("inlineCode",{parentName:"p"},"fun i\n-> if i = x then y else f i"))),(0,i.yg)("p",null,"The ",(0,i.yg)("inlineCode",{parentName:"p"},"find")," function doesn't modify the representatives, but they return the\ninput element's representative:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ocaml",metastring:"{5}","{5}":!0},"val find : 'a element -> 'a element\n(*@ e = find [u: 'a universe] x\n    requires Set.mem x u.dom\n    ensures Set.mem e u.dom\n    ensures e = u.rep x *)\n")),(0,i.yg)("p",null,"Finally, the postcondition for ",(0,i.yg)("inlineCode",{parentName:"p"},"union")," is a bit more involved. We need to\ncapture that the new representative of an element may change."),(0,i.yg)("p",null,"First, it's left unchanged if the element is not in ",(0,i.yg)("inlineCode",{parentName:"p"},"x")," nor ",(0,i.yg)("inlineCode",{parentName:"p"},"y")," subset."),(0,i.yg)("p",null,"Let's start by introducing a predicate that will help us decide if two elements\nare in the same subset (or equivalence class). This is the case if and only if\nthey have the same subset representative:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ocaml"},"(*@ predicate equiv (u: 'a universe) (x y: 'a element) =\n      u.rep x = u.rep y *)\n")),(0,i.yg)("p",null,"We can now use this to state that elements that aren't equivalent to ",(0,i.yg)("inlineCode",{parentName:"p"},"x")," or ",(0,i.yg)("inlineCode",{parentName:"p"},"y"),"\nhave the same representative:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ocaml",metastring:"{7-9}","{7-9}":!0},"val union : 'a element -> 'a element -> unit\n(*@ union [u: 'a universe] x y\n    requires Set.mem x u.dom\n    requires Set.mem y u.dom\n    modifies u\n    ensures u.dom = old u.dom\n    ensures forall e.\n      not (old (equiv u x e \\/ equiv u y e))\n      -> u.rep e = old (u.rep e) *)\n")),(0,i.yg)("p",null,"And finally, elements that were in the unioned subsets now must all have the\nsame representative, and that element is either the old ",(0,i.yg)("inlineCode",{parentName:"p"},"x")," representative, or\nthe old ",(0,i.yg)("inlineCode",{parentName:"p"},"y")," representative."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ocaml",metastring:"{9-13}","{9-13}":!0},"val union : 'a element -> 'a element -> unit\n(*@ union [u: 'a universe] x y\n    requires Set.mem x u.dom\n    requires Set.mem y u.dom\n    modifies u\n    ensures u.dom = old u.dom\n    ensures forall e. not (old (equiv u x e \\/ equiv u y e))\n                      -> u.rep e = old (u.rep e)\n    ensures exists r. (r = old (u.rep x) \\/ r = old (u.rep y))\n      /\\ forall e. old (equiv u x e \\/ equiv u y e)\n                   -> u.rep e = r *)\n")),(0,i.yg)("p",null,"We could go further and add more functions, like an equality function\nover elements or a ",(0,i.yg)("inlineCode",{parentName:"p"},"get")," function to extract an element's value,\nbut we'll keep it there for this tutorial. Hopefully, this gives you a\nbetter overview of the purpose of ghost types in Gospel specifications and how\nthey can help you refer to meta-elements not present or not exposed in the code."),(0,i.yg)("div",{className:"footnotes"},(0,i.yg)("hr",{parentName:"div"}),(0,i.yg)("ol",{parentName:"div"},(0,i.yg)("li",{parentName:"ol",id:"fn-1"},"If you're not comfortable with ghost arguments, you may want to ",(0,i.yg)("a",{parentName:"li",href:"fibonacci"},"read our\nFibonacci walk-through")," first.",(0,i.yg)("a",{parentName:"li",href:"#fnref-1",className:"footnote-backref"},"\u21a9")))))}d.isMDXComponent=!0}}]);