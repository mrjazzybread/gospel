"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[442],{5680:(e,n,t)=>{t.d(n,{xA:()=>p,yg:()=>d});var a=t(6540);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function c(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var l=a.createContext({}),s=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},p=function(e){var n=s(e.components);return a.createElement(l.Provider,{value:n},e.children)},g="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,p=c(e,["components","mdxType","originalType","parentName"]),g=s(t),m=i,d=g["".concat(l,".").concat(m)]||g[m]||u[m]||o;return t?a.createElement(d,r(r({ref:n},p),{},{components:t})):a.createElement(d,r({ref:n},p))}));function d(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var o=t.length,r=new Array(o);r[0]=m;var c={};for(var l in n)hasOwnProperty.call(n,l)&&(c[l]=n[l]);c.originalType=e,c[g]="string"==typeof e?e:i,r[1]=c;for(var s=2;s<o;s++)r[s]=t[s];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},7494:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>u,frontMatter:()=>o,metadata:()=>c,toc:()=>s});var a=t(8168),i=(t(6540),t(5680));const o={sidebar_position:7},r="Logical Declarations",c={unversionedId:"language/logical",id:"language/logical",title:"Logical Declarations",description:"Functions, Predicates and Axioms",source:"@site/docs/language/logical.md",sourceDirName:"language",slug:"/language/logical",permalink:"/gospel/language/logical",draft:!1,tags:[],version:"current",sidebarPosition:7,frontMatter:{sidebar_position:7},sidebar:"tutorialSidebar",previous:{title:"Function Contracts",permalink:"/gospel/language/function-contracts"},next:{title:"Symbols in Scope",permalink:"/gospel/language/scope"}},l={},s=[{value:"Functions, Predicates and Axioms",id:"functions-predicates-and-axioms",level:2},{value:"Logical Function Contracts",id:"logical-function-contracts",level:2},{value:"Termination Arguments",id:"termination-arguments",level:2}],p={toc:s},g="wrapper";function u(e){let{components:n,...t}=e;return(0,i.yg)(g,(0,a.A)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,i.yg)("h1",{id:"logical-declarations"},"Logical Declarations"),(0,i.yg)("h2",{id:"functions-predicates-and-axioms"},"Functions, Predicates and Axioms"),(0,i.yg)("p",null,"It's often convenient to introduce shortcuts for terms and formulas to avoid\nrepetitions. ",(0,i.yg)("em",{parentName:"p"},"Predicates")," let you write named formulae definitions in Gospel\ncomments. Here is a typical example:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ocaml"},"(*@ predicate is_sorted (a: int array) =\n      forall i j. 0 <= i <= j < Array.length a\n                  -> a.(i) <= a.(j) *)\n")),(0,i.yg)("p",null,"We can then reuse the predicate ",(0,i.yg)("inlineCode",{parentName:"p"},"is_sorted")," inside any Gospel annotations such\nas function contracts:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ocaml"},"val merge: int array -> int array -> int array\n(*@ c = merge a b\n    requires is_sorted a\n    requires is_sorted b\n    ensures is_sorted c *)\n")),(0,i.yg)("p",null,"Similarly, one can define a shortcut for terms using Gospel's ",(0,i.yg)("em",{parentName:"p"},"functions"),"."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ocaml"},"(*@ function powm (x y m: integer) : integer = mod (pow x y) m *)\n")),(0,i.yg)("p",null,"Both predicate definitions and function definitions may be\nrecursive. A recursive definition requires the ",(0,i.yg)("inlineCode",{parentName:"p"},"rec")," keyword like in OCaml:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ocaml"},"(*@ predicate rec is_sorted_list (l: int list) = match l with\n      | [] | _ :: [] -> true\n      | h :: (y :: _ as t) -> h <= y /\\ is_sorted_list t *)\n")),(0,i.yg)("p",null,"Logical functions and predicates can be left uninterpreted, ie without declaring\ntheir bodies, for instance:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ocaml"},"(*@ predicate is_sorted (a: int array) *)\n(*@ function powm (x y m: integer) : integer *)\n")),(0,i.yg)("p",null,"Finally, it is also possible to define ",(0,i.yg)("em",{parentName:"p"},"axioms"),", for instance:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ocaml"},"(*@ axiom unbounded_integers : forall i. exists j. j > i *)\n")),(0,i.yg)("h2",{id:"logical-function-contracts"},"Logical Function Contracts"),(0,i.yg)("p",null,"Similarly to OCaml functions, contracts can be added to logical declarations."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ocaml",metastring:"{3}","{3}":!0},"(*@ function rec fibonacci (n: integer) : integer =\n      if n <= 1 then n else fibonacci (n-2) + fibonacci (n-1) *)\n(*@ requires n >= 0 *)\n")),(0,i.yg)("p",null,"Such a contract doesn't prevent you from calling ",(0,i.yg)("inlineCode",{parentName:"p"},"fibonacci")," on negative\nintegers. For instance, ",(0,i.yg)("inlineCode",{parentName:"p"},"fibonacci (-1)")," is a valid Gospel term. However, we\nknow nothing about its value: the definition of ",(0,i.yg)("inlineCode",{parentName:"p"},"fibonacci")," holds only when its\nprecondition is true."),(0,i.yg)("p",null,"The above is equivalent to an uninterpreted function together with an axiom, as\nfollows:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ocaml"},"(*@ function fibonacci (n: integer) : integer *)\n\n(*@ axiom fibonacci_def : forall n. n >= 0 ->\n      fibonacci n =\n        if n <= 1 then n\n        else fibonacci (n-2) + fibonacci (n-1) *)\n")),(0,i.yg)("p",null,"Logical symbols can also come with postconditions. For instance, we can assert\nthat Fibonacci numbers are non-negative:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ocaml",metastring:"{4}","{4}":!0},"(*@ function rec fibonacci (n: integer) : integer =\n      if n <= 1 then n else fibonacci (n-2) + fibonacci (n-1) *)\n(*@ requires n >= 0\n    ensures result >= 0 *)\n")),(0,i.yg)("admonition",{type:"info"},(0,i.yg)("p",{parentName:"admonition"},"Note that as opposed to OCaml function contracts, logical function contracts don't\nhave a header. Consequently, Gospel automatically introduces a variable called ",(0,i.yg)("inlineCode",{parentName:"p"},"result"),"\nin the context to refer to the value returned by the\nfunction in a postcondition.")),(0,i.yg)("p",null,"The postcondition of ",(0,i.yg)("inlineCode",{parentName:"p"},"fibonacci")," is equivalent to adding an axiom along with an\nuninterpreted counterpart."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ocaml"},"(*@ axiom fibonacci_post : forall n. n >= 0 -> fibonacci n >= 0 *)\n")),(0,i.yg)("p",null,"Note that the postcondition holds only when the precondition holds."),(0,i.yg)("admonition",{type:"danger"},(0,i.yg)("p",{parentName:"admonition"},"Gospel doesn't perform any verification beyond type-checking. If you wish to\nverify that the definition indeed complies with its contract, you must use an\nexternal tool such as ",(0,i.yg)("a",{parentName:"p",href:"https://github.com/ocaml-gospel/why3gospel"},"Why3Gospel"),".")),(0,i.yg)("h2",{id:"termination-arguments"},"Termination Arguments"),(0,i.yg)("p",null,"Using recursive definitions in the logical domain can introduce inconsistencies.\nFor instance, consider the following recursive function:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ocaml"},"(*@ function rec f (n: integer): integer = f n + 1 *)\n")),(0,i.yg)("p",null,"As explained above, it's perfectly fine to mention ",(0,i.yg)("inlineCode",{parentName:"p"},"f 0")," in a formula. Although\nwe don't know its value, we know that ",(0,i.yg)("inlineCode",{parentName:"p"},"f 0 = f 0 + 1"),", thus ",(0,i.yg)("inlineCode",{parentName:"p"},"0 = 1"),", which is\nobviously inconsistent."),(0,i.yg)("p",null,"In order to prevent this, it's a good practice to provide a termination\nargument for each recursive definition. Gospel provides one way of doing this\nvia ",(0,i.yg)("em",{parentName:"p"},"variants"),"."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ocaml",metastring:"{4}","{4}":!0},"(*@ function rec fibonacci (n: integer) : integer =\n      if n <= 1 then n else fibonacci (n-2) + fibonacci (n-1) *)\n(*@ requires n >= 0\n    variant n *)\n")),(0,i.yg)("admonition",{type:"danger"},(0,i.yg)("p",{parentName:"admonition"},"Similarly to contracts, Gospel doesn't perform any verification that the\nvariant indeed ensures the termination, it will only checks that it's of type\ninteger. It's up to an external tool to exploit the expression given as\n",(0,i.yg)("inlineCode",{parentName:"p"},"variant")," to check termination.")))}u.isMDXComponent=!0}}]);