"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[165],{5680:(e,t,r)=>{r.d(t,{xA:()=>c,yg:()=>f});var o=r(6540);function n(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function a(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,o)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?a(Object(r),!0).forEach((function(t){n(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,o,n=function(e,t){if(null==e)return{};var r,o,n={},a=Object.keys(e);for(o=0;o<a.length;o++)r=a[o],t.indexOf(r)>=0||(n[r]=e[r]);return n}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)r=a[o],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(n[r]=e[r])}return n}var l=o.createContext({}),p=function(e){var t=o.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},c=function(e){var t=p(e.components);return o.createElement(l.Provider,{value:t},e.children)},u="mdxType",g={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},h=o.forwardRef((function(e,t){var r=e.components,n=e.mdxType,a=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=p(r),h=n,f=u["".concat(l,".").concat(h)]||u[h]||g[h]||a;return r?o.createElement(f,i(i({ref:t},c),{},{components:r})):o.createElement(f,i({ref:t},c))}));function f(e,t){var r=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var a=r.length,i=new Array(a);i[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[u]="string"==typeof e?e:n,i[1]=s;for(var p=2;p<a;p++)i[p]=r[p];return o.createElement.apply(null,i)}return o.createElement.apply(null,r)}h.displayName="MDXCreateElement"},9322:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>g,frontMatter:()=>a,metadata:()=>s,toc:()=>p});var o=r(8168),n=(r(6540),r(5680));const a={sidebar_position:3},i="Now What?",s={unversionedId:"getting-started/tools",id:"getting-started/tools",title:"Now What?",description:"You've written your first specification. Now what can you do with it?",source:"@site/docs/getting-started/tools.md",sourceDirName:"getting-started",slug:"/getting-started/tools",permalink:"/gospel/getting-started/tools",draft:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Your First Specification",permalink:"/gospel/getting-started/first-spec"},next:{title:"Going Further",permalink:"/gospel/getting-started/going-further"}},l={},p=[{value:"Cameleer",id:"cameleer",level:2},{value:"Ortac",id:"ortac",level:2},{value:"Why3gospel",id:"why3gospel",level:2}],c={toc:p},u="wrapper";function g(e){let{components:t,...r}=e;return(0,n.yg)(u,(0,o.A)({},c,r,{components:t,mdxType:"MDXLayout"}),(0,n.yg)("h1",{id:"now-what"},"Now What?"),(0,n.yg)("p",null,"You've written your first specification. Now what can you do with it?"),(0,n.yg)("p",null,"Your specification alone is already helpful, as it completes the\ndocstring, which may be incomplete or ambiguous. That could lead to incorrect\ninterpretations of your semantics, or wrong usage of your library."),(0,n.yg)("p",null,"Besides the ",(0,n.yg)("inlineCode",{parentName:"p"},"gospel")," binary, we also provide a developer API which lets other\ntools leverage these specifications to provide different features. Such tools\nalready exist and let you benefit from the specification, which brings more\nguarantees to your programs."),(0,n.yg)("h2",{id:"cameleer"},"Cameleer"),(0,n.yg)("p",null,"Cameleer is a tool for deductive verification of OCaml code."),(0,n.yg)("p",null,"It extends Gospel to implementation files, where you may add logical annotations\nlike logical assertions, loop invariants, or termination arguments. The\nverification relies on the ",(0,n.yg)("a",{parentName:"p",href:"https://why3.lri.fr"},"Why3")," framework. Cameleer\ntranslates the OCaml code into an equivalent WhyML program. It then lets you\nanalyse this program within the framework (and its IDE!) to prove the\nassertions via semi-automated techniques based on SMT provers."),(0,n.yg)("p",null,"For more information, please visit the project page ",(0,n.yg)("a",{parentName:"p",href:"https://github.com/ocaml-gospel/cameleer"},"on\nGithub"),"."),(0,n.yg)("h2",{id:"ortac"},"Ortac"),(0,n.yg)("p",null,"Ortac is a testing tool for OCaml programs."),(0,n.yg)("p",null,"It reads the Gospel specifications in the interfaces and generates code to test\nthat they hold at runtime. It comes with a couple of plugins that provide\ndifferent ways to run those tests. You may use it to generate testing suites and\nfuzzers or monitor your program execution."),(0,n.yg)("p",null,"For more information, please visit the project page ",(0,n.yg)("a",{parentName:"p",href:"https://github.com/ocaml-gospel/ortac"},"on\nGithub"),"."),(0,n.yg)("h2",{id:"why3gospel"},"Why3gospel"),(0,n.yg)("p",null,"Why3gospel is a ",(0,n.yg)("a",{parentName:"p",href:"https://why3.lri.fr"},"Why3")," plugin that lets you verify that a\nprogram proof refines the Gospel specifications before extracting it to OCaml."),(0,n.yg)("p",null,"It interfaces the Why3 framework with the Gospel specifications to ensure that\nthe former refines the latter and to guarantee that OCaml programs extracted\nfrom proved WhyML comply with their Gospel specification."),(0,n.yg)("p",null,"For more information, please visit the project page ",(0,n.yg)("a",{parentName:"p",href:"https://github.com/ocaml-gospel/why3gospel"},"on\nGithub"),"."))}g.isMDXComponent=!0}}]);