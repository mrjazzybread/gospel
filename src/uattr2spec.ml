(**************************************************************************)
(*                                                                        *)
(*  GOSPEL -- A Specification Language for OCaml                          *)
(*                                                                        *)
(*  Copyright (c) 2018- The VOCaL Project                                 *)
(*                                                                        *)
(*  This software is free software, distributed under the MIT license     *)
(*  (as described in file LICENSE enclosed).                              *)
(**************************************************************************)

module W = Warnings
open Ppxlib
open Uast.ParseUast

let is_spec attr = attr.attr_name.txt = "gospel"

let rec get_spec_attr = function
  | [] -> (None, [])
  | h :: t when is_spec h -> (Some h, t)
  | h :: t ->
      let elt, rest = get_spec_attr t in
      (elt, h :: rest)

let get_spec_content attr =
  match attr.attr_payload with
  | PStr
      [
        {
          pstr_desc =
            Pstr_eval
              ( {
                  pexp_desc = Pexp_constant (Pconst_string (spec, spec_loc, _));
                  _;
                },
                _ );
          _;
        };
      ] ->
      (spec, spec_loc)
  | _ -> assert false

let get_spec_loc attr = snd (get_spec_content attr)

let parse_gospel ~filename parse attr =
  let spec, spec_loc = get_spec_content attr in
  let lb = Lexing.from_string spec in
  Lexing.set_position lb spec_loc.loc_start;
  Lexing.set_filename lb filename;
  try (spec, parse Ulexer.token lb)
  with Uparser.Error ->
    let loc =
      { loc_start = lb.lex_start_p; loc_end = lb.lex_curr_p; loc_ghost = false }
    in
    W.error ~loc W.Syntax_error

let ptype_kind = function
  | Ptype_abstract -> PTtype_abstract
  | _ -> assert false

let params_to_id =
  let param_to_id (core_type, _) =
    let loc = core_type.ptyp_loc in
    match core_type.ptyp_desc with
    | Ptyp_var s -> Preid.create s ~loc
    | Ptyp_any ->
        W.error ~loc
          (W.unsupported ~loc
             "Wildcard type variables not supported in type declarations")
    | _ -> assert false
    (* There are no other possible values for type parameters in type declarations *)
  in
  List.map param_to_id

let preid_of_loc s = Preid.create ~loc:s.loc s.txt

let rec preid_of_long (loc : location) (s : longident) =
  let preid_of_long = preid_of_long loc in
  match s with
  | Lident id -> Qid (Preid.create ~loc id)
  | Ldot (id, s) -> Qdot (preid_of_long id, Preid.create ~loc s)
  | _ -> assert false

(** Converts a private flag generated by the OCaml compiler into a Gospel
    private flag. *)
let private_flag = function Asttypes.Private -> Private | Public -> Public

let rec core_to_pty cty =
  let loc = cty.ptyp_loc in
  match cty.ptyp_desc with
  | Ptyp_var str -> PTtyvar (Preid.create ~loc str)
  | Ptyp_constr (id, l) ->
      PTtyapp (preid_of_long id.loc id.txt, List.map core_to_pty l)
  | Ptyp_arrow (_, t1, t2) -> PTarrow (core_to_pty t1, core_to_pty t2)
  | Ptyp_tuple l -> PTtuple (List.map core_to_pty l)
  | _ -> assert false (* TODO replace with unsupported*)

let mk_tdecl t attrs spec =
  {
    tname = preid_of_loc t.ptype_name;
    tparams = params_to_id t.ptype_params;
    tkind = ptype_kind t.ptype_kind;
    tprivate = private_flag t.ptype_private;
    tmanifest = Option.map core_to_pty t.ptype_manifest;
    tattributes = attrs;
    tspec = spec;
    tloc = t.ptype_loc;
  }

let type_declaration ~filename t =
  let spec_attr, other_attrs = get_spec_attr t.ptype_attributes in
  let parse attr =
    let ty_text, spec = parse_gospel ~filename Uparser.type_spec attr in
    let ty_loc = get_spec_loc attr in
    { spec with ty_text; ty_loc }
  in
  let spec = Option.map parse spec_attr in
  mk_tdecl t other_attrs spec

let val_description ~filename v =
  let spec_attr, other_attrs = get_spec_attr v.pval_attributes in
  let parse attr =
    let sp_text, spec = parse_gospel ~filename Uparser.val_spec attr in
    let sp_loc = get_spec_loc attr in
    { spec with sp_text; sp_loc }
  in
  let spec = Option.map parse spec_attr in
  {
    vname = v.pval_name;
    vtype = v.pval_type;
    vprim = v.pval_prim;
    vattributes = other_attrs;
    vspec = spec;
    vloc = v.pval_loc;
  }

let floating_spec ~filename a =
  let txt, s = parse_gospel ~filename Uparser.top a in
  Sig_gospel (s, txt)

let with_constraint c =
  let no_spec_type_decl t = mk_tdecl t t.ptype_attributes None in
  match c with
  | Pwith_type (l, t) -> Wtype (l, no_spec_type_decl t)
  | Pwith_module (l1, l2) -> Wmodule (l1, l2)
  | Pwith_typesubst (l, t) -> Wtypesubst (l, no_spec_type_decl t)
  | Pwith_modsubst (l1, l2) -> Wmodsubst (l1, l2)
  | Pwith_modtype (l1, l2) -> Wmodtype (l1, l2)
  | Pwith_modtypesubst (l1, l2) -> Wmodtypesubst (l1, l2)

let rec signature_item_desc ~filename = function
  | Psig_value v -> Sig_val (val_description ~filename v)
  | Psig_type (_, tl) -> Sig_type (List.map (type_declaration ~filename) tl)
  | Psig_attribute a ->
      if not (is_spec a) then Sig_attribute a else floating_spec ~filename a
  | Psig_module m -> Sig_module (module_declaration ~filename m)
  | Psig_recmodule d ->
      Sig_recmodule (List.map (module_declaration ~filename) d)
  | Psig_modtype d -> Sig_modtype (module_type_declaration ~filename d)
  | Psig_typext t -> Sig_typext t
  | Psig_exception e -> Sig_exception e
  | Psig_open o -> Sig_open o
  | Psig_include i -> Sig_include i
  | Psig_class c -> Sig_class c
  | Psig_class_type c -> Sig_class_type c
  | Psig_extension (e, a) -> Sig_extension (e, a)
  | Psig_typesubst s -> Sig_typesubst (List.map (type_declaration ~filename) s)
  | Psig_modsubst s -> Sig_modsubst s
  | Psig_modtypesubst s ->
      Sig_modtypesubst (module_type_declaration ~filename s)

and signature ~filename sigs =
  List.map
    (fun { psig_desc; psig_loc } ->
      let filename =
        match psig_loc.loc_start.pos_fname with
        | "" | "_none_" -> filename
        | f -> f
      in
      { sdesc = signature_item_desc ~filename psig_desc; sloc = psig_loc })
    sigs

and module_type_desc ~filename = function
  | Pmty_ident id -> Mod_ident id
  | Pmty_signature s -> Mod_signature (signature ~filename s)
  | Pmty_functor (fp, mt) ->
      Mod_functor (functor_parameter ~filename fp, module_type ~filename mt)
  | Pmty_with (m, c) ->
      Mod_with (module_type ~filename m, List.map with_constraint c)
  | Pmty_typeof m -> Mod_typeof m
  | Pmty_extension e -> Mod_extension e
  | Pmty_alias a -> Mod_alias a

and functor_parameter ~filename = function
  | Unit -> Unit
  | Named (s, m) -> Named (s, module_type ~filename m)

and module_type ~filename m =
  {
    mdesc = module_type_desc ~filename m.pmty_desc;
    mloc = m.pmty_loc;
    mattributes = m.pmty_attributes;
  }

and module_declaration ~filename m =
  let nm = m.pmd_name in
  {
    mdname = Option.map (fun id -> Preid.create ~loc:nm.loc id) nm.txt;
    mdtype = module_type ~filename m.pmd_type;
    mdattributes = m.pmd_attributes;
    mdloc = m.pmd_loc;
  }

and module_type_declaration ~filename m =
  {
    mtdname = m.pmtd_name;
    mtdtype = Option.map (module_type ~filename) m.pmtd_type;
    mtdattributes = m.pmtd_attributes;
    mtdloc = m.pmtd_loc;
  }
