(**************************************************************************)
(*                                                                        *)
(*  GOSPEL -- A Specification Language for OCaml                          *)
(*                                                                        *)
(*  Copyright (c) 2018- The VOCaL Project                                 *)
(*                                                                        *)
(*  This software is free software, distributed under the MIT license     *)
(*  (as described in file LICENSE enclosed).                              *)
(**************************************************************************)

module W = Warnings
open Ppxlib
open Uast.ParseUast
open Uast_utils

let is_spec attr = attr.attr_name.txt = "gospel"

let rec get_spec_attr = function
  | [] -> (None, [])
  | h :: t when is_spec h -> (Some h, t)
  | h :: t ->
      let elt, rest = get_spec_attr t in
      (elt, h :: rest)

let get_spec_content attr =
  match attr.attr_payload with
  | PStr
      [
        {
          pstr_desc =
            Pstr_eval
              ( {
                  pexp_desc = Pexp_constant (Pconst_string (spec, spec_loc, _));
                  _;
                },
                _ );
          _;
        };
      ] ->
      (spec, spec_loc)
  | _ -> assert false

let get_spec_loc attr = snd (get_spec_content attr)

let parse_gospel ~filename parse attr =
  let spec, spec_loc = get_spec_content attr in
  let lb = Lexing.from_string spec in
  Lexing.set_position lb spec_loc.loc_start;
  Lexing.set_filename lb filename;
  try (spec, parse Ulexer.token lb)
  with Uparser.Error ->
    let loc =
      { loc_start = lb.lex_start_p; loc_end = lb.lex_curr_p; loc_ghost = false }
    in
    W.error ~loc W.Syntax_error

let params_to_id =
  let param_to_id (core_type, _) =
    let loc = core_type.ptyp_loc in
    match core_type.ptyp_desc with
    | Ptyp_var s -> Some (Preid.create s ~loc)
    | Ptyp_any -> None
    | _ -> assert false
    (* There are no other possible values for type parameters in type declarations *)
  in
  map_option param_to_id

let preid_of_loc s = Preid.create ~loc:s.loc s.txt

let rec preid_of_long (loc : location) (s : longident) =
  let preid_of_long = preid_of_long loc in
  match s with
  | Lident id -> Qid (Preid.create ~loc id)
  | Ldot (id, s) -> Qdot (preid_of_long id, Preid.create ~loc s)
  | _ -> assert false

(** Converts a private flag generated by the OCaml compiler into a Gospel
    private flag. *)
let private_flag = function Asttypes.Private -> Private | Public -> Public

let rec core_to_pty cty =
  let loc = cty.ptyp_loc in
  match cty.ptyp_desc with
  | Ptyp_var str -> PTtyvar (Preid.create ~loc str)
  | Ptyp_constr (id, l) ->
      PTtyapp (preid_of_long id.loc id.txt, List.map core_to_pty l)
  | Ptyp_arrow (_, t1, t2) -> PTarrow (core_to_pty t1, core_to_pty t2)
  | Ptyp_tuple l -> PTtuple (List.map core_to_pty l)
  | _ -> assert false (* TODO replace with unsupported*)

let ptype_kind = function
  | Ptype_abstract -> PTtype_abstract
  | Ptype_record l ->
      let to_gospel_label l =
        {
          pld_name = preid_of_loc l.Ppxlib.pld_name;
          pld_mutable =
            (match l.pld_mutable with
            | Mutable -> Mutable
            | Immutable -> Immutable);
          pld_type = core_to_pty l.pld_type;
          pld_loc = l.pld_loc;
        }
      in
      PTtype_record (List.map to_gospel_label l)
  | _ -> assert false

let mk_tdecl t attrs spec =
  let* tparams = params_to_id t.ptype_params in
  {
    tname = preid_of_loc t.ptype_name;
    tparams;
    tkind = ptype_kind t.ptype_kind;
    tprivate = private_flag t.ptype_private;
    tmanifest = Option.map core_to_pty t.ptype_manifest;
    tattributes = attrs;
    tspec = spec;
    tloc = t.ptype_loc;
  }

let type_declaration ~filename t =
  let spec_attr, other_attrs = get_spec_attr t.ptype_attributes in
  let parse attr =
    let ty_text, spec = parse_gospel ~filename Uparser.type_spec attr in
    let ty_loc = get_spec_loc attr in
    { spec with ty_text; ty_loc }
  in
  let spec = Option.map parse spec_attr in
  mk_tdecl t other_attrs spec

let val_description ~filename v =
  let spec_attr, other_attrs = get_spec_attr v.pval_attributes in
  let parse attr =
    let sp_text, spec = parse_gospel ~filename Uparser.val_spec attr in
    let sp_loc = get_spec_loc attr in
    { spec with sp_text; sp_loc }
  in
  let spec = Option.map parse spec_attr in
  Option.map
    (fun spec ->
      {
        vname = preid_of_loc v.pval_name;
        vtype = core_to_pty v.pval_type;
        vprim = v.pval_prim;
        vattributes = other_attrs;
        vspec = spec;
        vloc = v.pval_loc;
      })
    spec

let floating_spec ~filename a =
  let txt, s = parse_gospel ~filename Uparser.top a in
  Sig_gospel (s, txt)

let sig_exception exn =
  let c = exn.ptyexn_constructor in
  let exn_id = preid_of_loc c.pext_name in
  let exn_loc = c.pext_loc in
  let exn_attributes = c.pext_attributes in
  let exn_args =
    match c.pext_kind with
    | Pext_decl ([], Pcstr_tuple args, _) -> List.map core_to_pty args
    | Pext_rebind _ -> assert false (* Cannot occur on an interface file. *)
    | _ -> assert false
  in
  { exn_id; exn_loc; exn_attributes; exn_args }

(** [signature_item_desc ~filename s] turns the OCaml signature [s] into an
    appropriate Gospel signature. If the signature [s] is unsupported by Gospel
    or is an OCaml value declaration without a specification, we return [None].
*)
let rec signature_item_desc ~filename = function
  | Psig_value v ->
      let* v = val_description ~filename v in
      Sig_val v
  | Psig_type (_, tl) ->
      let* tl = map_option (type_declaration ~filename) tl in
      Sig_type tl
  | Psig_attribute a ->
      if not (is_spec a) then Some (Sig_attribute a)
      else Some (floating_spec ~filename a)
  | Psig_module m ->
      let* decl = module_declaration ~filename m in
      Sig_module decl
  | Psig_exception e -> Some (Sig_exception (sig_exception e))
  (* Unsupported *)
  | Psig_recmodule _ -> None
  | Psig_modtype _ -> None
  | Psig_typext _ -> None
  | Psig_open _ -> None
  | Psig_include _ -> None
  | Psig_class _ -> None
  | Psig_class_type _ -> None
  | Psig_extension _ -> None
  | Psig_typesubst _ -> None
  | Psig_modsubst _ -> None
  | Psig_modtypesubst _ -> None

and signature ~filename sigs =
  List.filter_map
    (fun { psig_desc; psig_loc } ->
      let filename =
        match psig_loc.loc_start.pos_fname with
        | "" | "_none_" -> filename
        | f -> f
      in
      let sdesc = signature_item_desc ~filename psig_desc in
      Option.map (fun sdesc -> { sdesc; sloc = psig_loc }) sdesc)
    sigs

and module_type_desc ~filename = function
  | Pmty_signature s -> Some (Mod_signature (signature ~filename s))
  | Pmty_ident _ -> None
  | Pmty_functor _ -> None
  | Pmty_with _ -> None
  | Pmty_typeof _ -> None
  | Pmty_extension _ -> None
  | Pmty_alias _ -> None

and module_type ~filename m =
  let* mdesc = module_type_desc ~filename m.pmty_desc in
  { mdesc; mloc = m.pmty_loc; mattributes = m.pmty_attributes }

and module_declaration ~filename m =
  let nm = m.pmd_name in
  let* mdtype = module_type ~filename m.pmd_type in
  {
    mdname = Option.map (fun id -> Preid.create ~loc:nm.loc id) nm.txt;
    mdtype;
    mdattributes = m.pmd_attributes;
    mdloc = m.pmd_loc;
  }
